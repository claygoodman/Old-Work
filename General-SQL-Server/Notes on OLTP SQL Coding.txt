https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/survey-of-initial-areas-in-in-memory-oltp?view=sql-server-ver16

************
MEMORY_OPTIMIZED, on the CREATE TABLE statement; puts active table in memory for trans; rest on disk
When a transaction involves both a disk-based table and a memory-optimized table, we call that a cross-container transaction. In such a transaction it is essential that the memory-optimized portion of the transaction operate at the transaction isolation level named SNAPSHOT.

CREATE TABLE dbo.SalesOrder
    (
        SalesOrderId   integer   not null   IDENTITY
            PRIMARY KEY NONCLUSTERED,
        CustomerId   integer    not null,
        OrderDate    datetime   not null
    )
        WITH
            (MEMORY_OPTIMIZED = ON,
            DURABILITY = SCHEMA_AND_DATA);

***************
Each CREATE TABLE statement for a memory-optimized table must include an index, either explicitly through an INDEX or implicitly through a PRIMAY KEY or UNIQUE constraint.

ALTER TABLE...ADD/DROP can add or remove a column from a memory-optimized table, or an index.
CREATE INDEX and DROP INDEX cannot be run against a memory-optimized table, use ALTER TABLE ... ADD/DROP INDEX instead.

https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/indexes-for-memory-optimized-tables?view=sql-server-ver16
NOTE: Creating a clustered index is not necessary; but creating a UNIQUE constraint is in the primary key

Hash indexes are used for in-memory tables so a non clustered index that ties to the unique hash index is best to prevent degradation.
Hash indexes are primarily used for point lookups and not for range scans.
A hash index is preferable over a nonclustered index when queries use equality predicates

*******************
UNSUPPORTED HISTORICAL FEATURES FOR IN MEMORY OLTP
https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/transact-sql-constructs-not-supported-by-in-memory-oltp?view=sql-server-ver16
db snapshots
DBCC CHECKTABLE on in memory tables
DBCC CHECKDB skips hashes

Memory-optimized tables cannot be placed on a filegroup or partition scheme. Remove the ON clause from the CREATE TABLE statement. All memory optimized tables are mapped to memory-optimized filegroup.
READ UNCOMMITTED is not supported for natively compiled stored procedures. Use a supported isolation level, such as SNAPSHOT.
READ COMMITTED is not supported for natively compiled stored procedures. Use a supported isolation level, such as SNAPSHOT.
Temp Tables cannot be used in natively compiled stored procedures. Instead, use a table variable or a memory-optimized table with DURABILITY=SCHEMA_ONLY.
Natively compiled stored procedures cannot be invoked from transactions that have an active savepoint.
ALL cannot be used with GROUP BY clauses in natively compiled stored procedures.
Disk-based tables cannot be accessed from natively compiled stored procedures. 


see this URL for many important details


************
UNSUPPORTED DATA TYPES

datetimeoffset (Transact-SQL)
hierarchyid (Transact-SQL)
sql_variant (Transact-SQL)
geography (Transact-SQL)
rowversion (Transact-SQL)
User-Defined Types
geometry (Transact-SQL)
xml (Transact-SQL)

Computed columns are supported for memory-optimized tables in 2017 or later


***************
ALTER DATABASE CURRENT SET MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = ON;


On Microsoft SQL Server, before you can create a memory-optimized table you must first create a FILEGROUP that you declare CONTAINS MEMORY_OPTIMIZED_DATA.
the In-Memory OLTP engine still requires a memory-optimized filegroup for SCHEMA_ONLY memory-optimized tables to provide a uniform experience for databases with memory-optimized tables.
You can only create one memory-optimized filegroup per database. You need to explicitly mark the filegroup as containing memory_optimized_data

ALTER DATABASE imoltp ADD FILEGROUP imoltp_mod CONTAINS MEMORY_OPTIMIZED_DATA  
ALTER DATABASE imoltp ADD FILE (name='imoltp_mod1', filename='c:\data\imoltp_mod1') TO FILEGROUP imoltp_mod

OLTP Engine deploys filestream in memory; no need to declare filestream
The mapping to filestream is done by the In-Memory OLTP engine.

CAVEATS
DO NOT SPECIFY MAXSIZE
Consider creating multiple containers in the memory-optimized filegroup and distribute them on different drives to achieve more bandwidth to stream the data into memory.
If a MAXSIZE value is set for the memory-optimized filegroup, and checkpoint files exceed the max size of the container, then the database will become SUSPECT.
In this case do not attempt to set the database OFFLINE and ONLINE, causing the database to stay in RECOVERY_PENDING state.

https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/unsupported-sql-server-features-for-in-memory-oltp?view=sql-server-ver16

Regardless of the recovery model of the database, all operations on durable memory-optimized tables are always fully logged.
Database-level triggers and server-level DDL triggers aren't supported with In-Memory OLTP tables or with natively compiled modules.
Cannot access a queue from a natively compiled stored procedure.
Cannot access a queue in a remote database in a transaction that accesses memory-optimized tables.

Scenarios Not Supported
    Accessing memory-optimized tables by using the context connection from inside CLR stored procedures.
    Keyset and dynamic cursors on queries accessing memory-optimized tables. These cursors are degraded to static and read-only.
    Using MERGE INTO target, where target is a memory-optimized table, is unsupported.
        MERGE USING source is supported for memory-optimized tables.
    The ROWVERSION (TIMESTAMP) data type is not supported. For more information, see FROM (Transact-SQL).
    Auto-close is not supported with databases that have a MEMORY_OPTIMIZED_DATA filegroup
    Transactional DDL, such as CREATE/ALTER/DROP of In-Memory OLTP objects, is not supported inside user transactions.
    Event notification.
    Policy-based management (PBM).
        Prevent and log only modes of PBM aren't supported. Existence of such policies on the server may prevent In-Memory OLTP DDL from executing successfully. On-demand and on-schedule modes are supported.
    Database containment (Contained Databases) is not supported with In-Memory OLTP.
        Contained database authentication is supported. However, all In-Memory OLTP objects are marked as breaking containment in the dynamic management view (DMV) dm_db_uncontained_entities.



****************
NATIVE_COMPILATION, on the CREATE PROCEDURE statement --compiles to machine code on first use

There are three types of natively compiled modules:

    Natively compiled stored procedures.
    Natively compiled user-defined functions (UDFs), which are scalar.
    Natively compiled triggers.

SAMPLE
CREATE PROCEDURE ncspRetrieveLatestSalesOrderIdForCustomerId  
        @_CustomerId   INT  
        WITH  
            NATIVE_COMPILATION,  
            SCHEMABINDING  
    AS  
    BEGIN ATOMIC  
        WITH  
            (TRANSACTION ISOLATION LEVEL = SNAPSHOT,
            LANGUAGE = N'us_english')  
      
        DECLARE @SalesOrderId int, @OrderDate datetime;
      
        SELECT TOP 1  
                @SalesOrderId = s.SalesOrderId,  
                @OrderDate    = s.OrderDate  
            FROM dbo.SalesOrder AS s  
            WHERE s.CustomerId = @_CustomerId  
            ORDER BY s.OrderDate DESC;  
      
        RETURN @SalesOrderId;  
    END;  

you do not need to create a natively compiled stored procedure to access a memory-optimized table. You can also reference memory-optimized tables from traditional stored procedures and ad hoc batches.



***************

Ensure compatibility level >= 130 at db level
SELECT d.compatibility_level
    FROM sys.databases as d
    WHERE d.name = Db_Name();

Fix Here:
ALTER DATABASE CURRENT SET COMPATIBILITY_LEVEL = 130;